circuit ysyx_25030077_mem :
  module MaxPeriodFibonacciLFSR :
    input clock : Clock
    input reset : Reset
    output io : { flip seed : { valid : UInt<1>, bits : UInt<1>[16]}, flip increment : UInt<1>, out : UInt<1>[16]}

    wire _state_WIRE : UInt<1>[16] @[PRNG.scala 46:28]
    _state_WIRE[0] <= UInt<1>("h1") @[PRNG.scala 46:28]
    _state_WIRE[1] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[2] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[3] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[4] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[5] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[6] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[7] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[8] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[9] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[10] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[11] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[12] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[13] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[14] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[15] <= UInt<1>("h0") @[PRNG.scala 46:28]
    reg state : UInt<1>[16], clock with :
      reset => (reset, _state_WIRE) @[PRNG.scala 55:49]
    when io.increment : @[PRNG.scala 69:22]
      node _T = xor(state[15], state[13]) @[LFSR.scala 15:41]
      node _T_1 = xor(_T, state[12]) @[LFSR.scala 15:41]
      node _T_2 = xor(_T_1, state[10]) @[LFSR.scala 15:41]
      state[0] <= _T_2 @[PRNG.scala 70:11]
      state[1] <= state[0] @[PRNG.scala 70:11]
      state[2] <= state[1] @[PRNG.scala 70:11]
      state[3] <= state[2] @[PRNG.scala 70:11]
      state[4] <= state[3] @[PRNG.scala 70:11]
      state[5] <= state[4] @[PRNG.scala 70:11]
      state[6] <= state[5] @[PRNG.scala 70:11]
      state[7] <= state[6] @[PRNG.scala 70:11]
      state[8] <= state[7] @[PRNG.scala 70:11]
      state[9] <= state[8] @[PRNG.scala 70:11]
      state[10] <= state[9] @[PRNG.scala 70:11]
      state[11] <= state[10] @[PRNG.scala 70:11]
      state[12] <= state[11] @[PRNG.scala 70:11]
      state[13] <= state[12] @[PRNG.scala 70:11]
      state[14] <= state[13] @[PRNG.scala 70:11]
      state[15] <= state[14] @[PRNG.scala 70:11]
    when io.seed.valid : @[PRNG.scala 73:22]
      state[0] <= io.seed.bits[0] @[PRNG.scala 74:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 74:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 74:11]
      state[3] <= io.seed.bits[3] @[PRNG.scala 74:11]
      state[4] <= io.seed.bits[4] @[PRNG.scala 74:11]
      state[5] <= io.seed.bits[5] @[PRNG.scala 74:11]
      state[6] <= io.seed.bits[6] @[PRNG.scala 74:11]
      state[7] <= io.seed.bits[7] @[PRNG.scala 74:11]
      state[8] <= io.seed.bits[8] @[PRNG.scala 74:11]
      state[9] <= io.seed.bits[9] @[PRNG.scala 74:11]
      state[10] <= io.seed.bits[10] @[PRNG.scala 74:11]
      state[11] <= io.seed.bits[11] @[PRNG.scala 74:11]
      state[12] <= io.seed.bits[12] @[PRNG.scala 74:11]
      state[13] <= io.seed.bits[13] @[PRNG.scala 74:11]
      state[14] <= io.seed.bits[14] @[PRNG.scala 74:11]
      state[15] <= io.seed.bits[15] @[PRNG.scala 74:11]
    io.out <= state @[PRNG.scala 78:10]

  module MaxPeriodFibonacciLFSR_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip seed : { valid : UInt<1>, bits : UInt<1>[3]}, flip increment : UInt<1>, out : UInt<1>[3]}

    wire _state_WIRE : UInt<1>[3] @[PRNG.scala 46:28]
    _state_WIRE[0] <= UInt<1>("h1") @[PRNG.scala 46:28]
    _state_WIRE[1] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[2] <= UInt<1>("h0") @[PRNG.scala 46:28]
    reg state : UInt<1>[3], clock with :
      reset => (reset, _state_WIRE) @[PRNG.scala 55:49]
    when io.increment : @[PRNG.scala 69:22]
      node _T = xor(state[2], state[1]) @[LFSR.scala 15:41]
      state[0] <= _T @[PRNG.scala 70:11]
      state[1] <= state[0] @[PRNG.scala 70:11]
      state[2] <= state[1] @[PRNG.scala 70:11]
    when io.seed.valid : @[PRNG.scala 73:22]
      state[0] <= io.seed.bits[0] @[PRNG.scala 74:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 74:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 74:11]
    io.out <= state @[PRNG.scala 78:10]

  module ysyx_25030077_mem :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip ar : { flip ready : UInt<1>, valid : UInt<1>, bits : { }}, flip aw : { flip ready : UInt<1>, valid : UInt<1>, bits : { }}, flip w : { flip ready : UInt<1>, valid : UInt<1>, bits : { }}, flip waddr : UInt<32>, flip raddr : UInt<32>, flip wdata : UInt<32>, flip r_mask : UInt<3>, flip w_mask : UInt<3>, mem_data : UInt<32>, r : { flip ready : UInt<1>, valid : UInt<1>, bits : { }}, b : { flip ready : UInt<1>, valid : UInt<1>, bits : { }}, b_resp : UInt<2>}

    reg mem_data_Reg : UInt<32>, clock with :
      reset => (reset, UInt<32>("h0")) @[ysyx_25030077_mem.scala 22:29]
    reg validReg : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[ysyx_25030077_mem.scala 23:25]
    inst canAccept_prng of MaxPeriodFibonacciLFSR @[PRNG.scala 91:22]
    canAccept_prng.clock <= clock
    canAccept_prng.reset <= reset
    canAccept_prng.io.seed.valid <= UInt<1>("h0") @[PRNG.scala 92:24]
    canAccept_prng.io.seed.bits[0] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[1] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[2] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[3] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[4] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[5] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[6] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[7] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[8] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[9] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[10] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[11] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[12] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[13] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[14] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.seed.bits[15] is invalid @[PRNG.scala 93:23]
    canAccept_prng.io.increment <= UInt<1>("h1") @[PRNG.scala 94:23]
    node canAccept_lo_lo_lo = cat(canAccept_prng.io.out[1], canAccept_prng.io.out[0]) @[PRNG.scala 95:17]
    node canAccept_lo_lo_hi = cat(canAccept_prng.io.out[3], canAccept_prng.io.out[2]) @[PRNG.scala 95:17]
    node canAccept_lo_lo = cat(canAccept_lo_lo_hi, canAccept_lo_lo_lo) @[PRNG.scala 95:17]
    node canAccept_lo_hi_lo = cat(canAccept_prng.io.out[5], canAccept_prng.io.out[4]) @[PRNG.scala 95:17]
    node canAccept_lo_hi_hi = cat(canAccept_prng.io.out[7], canAccept_prng.io.out[6]) @[PRNG.scala 95:17]
    node canAccept_lo_hi = cat(canAccept_lo_hi_hi, canAccept_lo_hi_lo) @[PRNG.scala 95:17]
    node canAccept_lo = cat(canAccept_lo_hi, canAccept_lo_lo) @[PRNG.scala 95:17]
    node canAccept_hi_lo_lo = cat(canAccept_prng.io.out[9], canAccept_prng.io.out[8]) @[PRNG.scala 95:17]
    node canAccept_hi_lo_hi = cat(canAccept_prng.io.out[11], canAccept_prng.io.out[10]) @[PRNG.scala 95:17]
    node canAccept_hi_lo = cat(canAccept_hi_lo_hi, canAccept_hi_lo_lo) @[PRNG.scala 95:17]
    node canAccept_hi_hi_lo = cat(canAccept_prng.io.out[13], canAccept_prng.io.out[12]) @[PRNG.scala 95:17]
    node canAccept_hi_hi_hi = cat(canAccept_prng.io.out[15], canAccept_prng.io.out[14]) @[PRNG.scala 95:17]
    node canAccept_hi_hi = cat(canAccept_hi_hi_hi, canAccept_hi_hi_lo) @[PRNG.scala 95:17]
    node canAccept_hi = cat(canAccept_hi_hi, canAccept_hi_lo) @[PRNG.scala 95:17]
    node _canAccept_T = cat(canAccept_hi, canAccept_lo) @[PRNG.scala 95:17]
    node canAccept = bits(_canAccept_T, 0, 0) @[ysyx_25030077_mem.scala 24:28]
    node _read_data_T = xor(io.waddr, io.raddr) @[ysyx_25030077_mem.scala 25:29]
    node _read_data_T_1 = or(io.r_mask, io.w_mask) @[ysyx_25030077_mem.scala 25:68]
    node read_data_lo = cat(io.aw.valid, io.w.valid) @[Cat.scala 31:58]
    node read_data_hi = cat(UInt<27>("h0"), _read_data_T_1) @[Cat.scala 31:58]
    node _read_data_T_2 = cat(read_data_hi, read_data_lo) @[Cat.scala 31:58]
    node read_data = xor(_read_data_T, _read_data_T_2) @[ysyx_25030077_mem.scala 25:40]
    reg delayCnt : UInt<3>, clock with :
      reset => (reset, UInt<3>("h0")) @[ysyx_25030077_mem.scala 27:25]
    wire startDelay : UInt<1>
    startDelay <= UInt<1>("h0")
    node r_valid_1 = gt(io.r_mask, UInt<1>("h0")) @[ysyx_25030077_mem.scala 29:29]
    node _startDelay_T = and(io.ar.valid, canAccept) @[ysyx_25030077_mem.scala 31:29]
    node _startDelay_T_1 = and(_startDelay_T, r_valid_1) @[ysyx_25030077_mem.scala 31:42]
    startDelay <= _startDelay_T_1 @[ysyx_25030077_mem.scala 31:14]
    inst lfsrValue_prng of MaxPeriodFibonacciLFSR_1 @[PRNG.scala 91:22]
    lfsrValue_prng.clock <= clock
    lfsrValue_prng.reset <= reset
    lfsrValue_prng.io.seed.valid <= UInt<1>("h0") @[PRNG.scala 92:24]
    lfsrValue_prng.io.seed.bits[0] is invalid @[PRNG.scala 93:23]
    lfsrValue_prng.io.seed.bits[1] is invalid @[PRNG.scala 93:23]
    lfsrValue_prng.io.seed.bits[2] is invalid @[PRNG.scala 93:23]
    lfsrValue_prng.io.increment <= UInt<1>("h1") @[PRNG.scala 94:23]
    node lfsrValue_hi = cat(lfsrValue_prng.io.out[2], lfsrValue_prng.io.out[1]) @[PRNG.scala 95:17]
    node lfsrValue = cat(lfsrValue_hi, lfsrValue_prng.io.out[0]) @[PRNG.scala 95:17]
    node _adjustedLfsr_T = eq(lfsrValue, UInt<1>("h1")) @[ysyx_25030077_mem.scala 36:36]
    node adjustedLfsr = mux(_adjustedLfsr_T, UInt<3>("h2"), lfsrValue) @[ysyx_25030077_mem.scala 36:25]
    node _delayCnt_T = eq(delayCnt, UInt<1>("h0")) @[ysyx_25030077_mem.scala 37:43]
    node _delayCnt_T_1 = and(startDelay, _delayCnt_T) @[ysyx_25030077_mem.scala 37:31]
    node _delayCnt_T_2 = neq(delayCnt, UInt<1>("h0")) @[ysyx_25030077_mem.scala 38:28]
    node _delayCnt_T_3 = sub(delayCnt, UInt<1>("h1")) @[ysyx_25030077_mem.scala 38:46]
    node _delayCnt_T_4 = tail(_delayCnt_T_3, 1) @[ysyx_25030077_mem.scala 38:46]
    node _delayCnt_T_5 = mux(_delayCnt_T_2, _delayCnt_T_4, UInt<1>("h0")) @[ysyx_25030077_mem.scala 38:18]
    node _delayCnt_T_6 = mux(_delayCnt_T_1, adjustedLfsr, _delayCnt_T_5) @[ysyx_25030077_mem.scala 37:18]
    delayCnt <= _delayCnt_T_6 @[ysyx_25030077_mem.scala 37:12]
    node _io_r_valid_T = eq(delayCnt, UInt<1>("h0")) @[ysyx_25030077_mem.scala 41:39]
    node _io_r_valid_T_1 = eq(delayCnt, UInt<1>("h1")) @[ysyx_25030077_mem.scala 41:59]
    node _io_r_valid_T_2 = or(_io_r_valid_T, _io_r_valid_T_1) @[ysyx_25030077_mem.scala 41:47]
    node _io_r_valid_T_3 = and(validReg, _io_r_valid_T_2) @[ysyx_25030077_mem.scala 41:26]
    io.r.valid <= _io_r_valid_T_3 @[ysyx_25030077_mem.scala 41:14]
    node _io_b_valid_T = eq(delayCnt, UInt<1>("h0")) @[ysyx_25030077_mem.scala 42:39]
    node _io_b_valid_T_1 = eq(delayCnt, UInt<1>("h1")) @[ysyx_25030077_mem.scala 42:59]
    node _io_b_valid_T_2 = or(_io_b_valid_T, _io_b_valid_T_1) @[ysyx_25030077_mem.scala 42:47]
    node _io_b_valid_T_3 = and(validReg, _io_b_valid_T_2) @[ysyx_25030077_mem.scala 42:26]
    io.b.valid <= _io_b_valid_T_3 @[ysyx_25030077_mem.scala 42:14]
    io.b_resp <= UInt<1>("h0") @[ysyx_25030077_mem.scala 43:13]
    io.mem_data <= mem_data_Reg @[ysyx_25030077_mem.scala 45:15]
    node _validReg_T = and(io.ar.valid, canAccept) @[ysyx_25030077_mem.scala 47:31]
    node _validReg_T_1 = and(io.b.ready, io.r.ready) @[ysyx_25030077_mem.scala 48:30]
    node _validReg_T_2 = eq(delayCnt, UInt<1>("h0")) @[ysyx_25030077_mem.scala 48:57]
    node _validReg_T_3 = and(_validReg_T_1, _validReg_T_2) @[ysyx_25030077_mem.scala 48:44]
    node _validReg_T_4 = mux(_validReg_T_3, UInt<1>("h0"), validReg) @[ysyx_25030077_mem.scala 48:18]
    node _validReg_T_5 = mux(_validReg_T, UInt<1>("h1"), _validReg_T_4) @[ysyx_25030077_mem.scala 47:18]
    validReg <= _validReg_T_5 @[ysyx_25030077_mem.scala 47:12]
    node _mem_data_Reg_T = and(io.ar.valid, canAccept) @[ysyx_25030077_mem.scala 50:35]
    node _mem_data_Reg_T_1 = mux(_mem_data_Reg_T, read_data, mem_data_Reg) @[ysyx_25030077_mem.scala 50:22]
    mem_data_Reg <= _mem_data_Reg_T_1 @[ysyx_25030077_mem.scala 50:16]
    io.ar.ready <= canAccept @[ysyx_25030077_mem.scala 52:15]
    io.aw.ready <= canAccept @[ysyx_25030077_mem.scala 53:15]
    io.w.ready <= canAccept @[ysyx_25030077_mem.scala 54:15]

